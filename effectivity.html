<!DOCTYPE html>
<html>
<meta charset="UTF-8">
<head>
<script type="text/javascript">
// ------------------------------------- JS HELPERS ---------------------------------------------------------
function createElement( type, invars ) {

}

// ------------------------------------- PKMN related classes helpers ---------------------------------------

const effectivityValueGood = 1.4;
const effectivityValueNeutral = 1;
const effectivityValueBad = 0.71;
const effectivityValueVeryBad = 0.51;

class Type {
   constructor( name, css )
   {
      this.css = css;
      this.name = name;
      this.good = undefined;
      this.bad = undefined;
      this.veryBad = undefined;
   }
   getEffectivityAgainstTarget( target )
   {
      if ( this.good.includes( target ) ) return effectivityValueGood;
      else if ( this.bad.includes( target ) ) return effectivityValueBad;
      else if ( this.veryBad.includes( target ) ) return effectivityValueVeryBad;
      else return effectivityValueNeutral;
   }
   getEffectivityAgainstTargets( targets )
   {
      let effectivity = effectivityValueNeutral;
      for ( t in targets )
      {
         effectivity *= this.getEffectivityAgainstTarget( targets[t] );
      }
      return Math.round( effectivity * 100) / 100;
   }
   setEffectivity( good, bad, veryBad )
   {
      this.good = good;
      this.bad = bad;
      this.veryBad = veryBad;
   }
}

let Bug = new Type("Bug", "bug");
let Dark = new Type("Dark", "dark");
let Dragon = new Type("Dragon", "dragon");
let Electric = new Type("Electric", "electric");
let Fairy = new Type("Fairy", "fairy");
let Fighting = new Type("Fighting", "fighting");
let Fire = new Type("Fire", "fire");
let Flying = new Type("Flying", "flying");
let Ghost = new Type("Ghost", "ghost");
let Grass = new Type("Grass", "grass");
let Ground = new Type("Ground", "ground");
let Ice = new Type("Ice", "ice");
let Normal = new Type("Normal", "normal");
let Poison = new Type("Poison", "poison");
let Psychic = new Type("Psychic", "psychic");
let Rock = new Type("Rock", "rock");
let Steel = new Type("Steel", "steel");
let Water = new Type("Water", "water");

// ----------------------- GOOD ---------------------------------- BAD --------------------------------------------------- VERY BAD ---
Bug.setEffectivity(      [ Dark, Grass, Psychic                ],[ Fairy, Fighting, Fire, Flying, Ghost, Poison, Steel ],[          ]);
Dark.setEffectivity(     [ Ghost, Psychic                      ],[ Dark, Fairy, Fighting                               ],[          ]);
Dragon.setEffectivity(   [ Dragon                              ],[ Steel                                               ],[ Fairy    ]);
Electric.setEffectivity( [ Flying, Water                       ],[ Dragon, Electric, Grass                             ],[ Ground   ]);
Fairy.setEffectivity(    [ Dark, Dragon, Fighting              ],[ Fire, Poison, Steel                                 ],[          ]);
Fighting.setEffectivity( [ Dark, Ice, Normal, Rock, Steel      ],[ Bug, Fairy, Flying, Poison, Psychic                 ],[ Ghost    ]);
Fire.setEffectivity(     [ Bug, Grass, Ice, Steel              ],[ Dragon, Fire, Rock, Water                           ],[          ]);
Flying.setEffectivity(   [ Bug, Fighting, Grass                ],[ Electric, Rock, Steel                               ],[          ]);
Ghost.setEffectivity(    [ Ghost, Psychic                      ],[ Dark                                                ],[ Normal   ]);
Grass.setEffectivity(    [ Ground, Rock, Water                 ],[ Bug, Dragon, Fire, Flying, Grass, Poison,Steel      ],[          ]);
Ground.setEffectivity(   [ Electric, Fire, Poison, Rock, Steel ],[ Bug, Grass                                          ],[ Flying   ]);
Ice.setEffectivity(      [ Dragon, Flying, Grass, Ground       ],[ Fire, Ice, Steel, Water                             ],[          ]);
Normal.setEffectivity(   [                                     ],[ Rock, Steel                                         ],[ Ghost    ]);
Poison.setEffectivity(   [ Fairy, Grass                        ],[ Ghost, Ground, Poison, Rock                         ],[ Steel    ]);
Psychic.setEffectivity(  [ Fighting, Poison                    ],[ Psychic, Steel                                      ],[ Dark     ]);
Rock.setEffectivity(     [ Bug, Fire, Flying, Ice              ],[ Fighting, Ground, Steel                             ],[          ]);
Steel.setEffectivity(    [ Fairy, Ice, Rock                    ],[ Electric, Fire, Steel, Water                        ],[          ]);
Water.setEffectivity(    [ Fire, Ground, Rock                  ],[ Dragon, Grass, Water                                ],[          ]);
// ------------------------------------------------------------------------------------------------------------------------------------

const TYPES = [ Bug,Dark,Dragon,Electric,Fairy,Fighting,Fire,Flying,Ghost,Grass,Ground,Ice,Normal,Poison,Psychic,Rock,Steel,Water ];

for ( t in TYPES ) Object.freeze( TYPES[t] );

// ------------------------------------- more code ------------------------------------------------------

/*
class VisibleEntity
{
   constructor(parent)
   {
      this.children = [];
      this.isVisible = true;
      this._parent = parent;
      this._htmlElement = undefined;
      this._isSelected = false;
   }
   set visible( bool )
   {
      this.isVisible = Boolean(bool);
   }
   get selected()
   {
      return this._isSelected;
   }
   set selected( bool )
   {
      this._isSelected = Boolean(bool);
   }
   get htmlElement()
   {
      return this._htmlElement;
   }
   set htmlElement( ele )
   {
      this._htmlElement = ele;
   }
   get parent()
   {
      return this._parent;
   }
   set parent( ele )
   {
      this._parent = ele;
   }
   addChild( child )
   {
      this.children.push( child );
   }
   toggleClass( className )
   {
      if ( this.htmlElement.classList.contains( className ) )
      {
         this.htmlElement.classList.remove( className );
         this.isSelected = false;
      }
      else
      {
         this.htmlElement.classList.add( className );
         this.isSelected = true;
      }
   }
   removeFrom = function( arr )
   {
      let index = arr.indexOf( this );
      if ( index > -1 )
      {
         arr.splice( index, 1 );
      }
      return this;
   }
   create( type, vars, parent )
   {
      this.htmlElement = createElement( type, vars );
      this.htmlElement.visibleEntity = this;

      if ( this.isVisible && !this.htmlElement.classList.contains(INVISIBLE_ELEMENT_CLASS) )
      {
         this.htmlElement.classList.add(INVISIBLE_ELEMENT_CLASS);
      }
      if ( this.isSelected && !this.htmlElement.classList.contains(SELECTED_ELEMENT_CLASS) )
      {
         this.htmlElement.classList.add(SELECTED_ELEMENT_CLASS);
      }

      for ( const child in this.children )
      {
         this.htmlElement.appendChild( this.children[child].create() );
      }
      return this.htmlElement;
   }
}

class TypeIcon extends VisibleEntity
{
   constructor( type )
   {
      super();
      this.type = type;
   }
   create(parent)
   {
      return super.create( "div",
                           {  class:"typeIcon "+this.type.css,
                              innerHTML:this.type.name
                           },
                           (parent) ? parent : this );
         
   }
}

class Button extends TypeIcon // final
{
   constructor( type, container, onClickProc )
   {
      super(type);
      super.parent = this;
      this.buttonContainer = container;
      this.onClickProc = onClickProc;
   }
   onClick(e, buttonContainer)
   {
      const element = (e.currentTarget) ? e.currentTarget : e.srcElement;
   
      const entity = element.visibleEntity;
      let container = buttonContainer.selectedButtons;

      if ( container.includes( entity ) )
      {
         console.log("Button.onClick: container.includes( entity )");
         entity.removeFrom( container );
      }
      else if ( container.length < 2 )
      {
         console.log("Button.onClick: container.length < 2");
         container.push( entity );
      }
      else
      {
         console.log("Button.onClick: fallback");
         container.shift().toggleClass( SELECTED_ELEMENT_CLASS );
         container.push( entity );
      }
      entity.toggleClass( SELECTED_ELEMENT_CLASS );
   }
   create()
   {
      let elem = super.create( this );
      let self = this;
      elem.onclick = function(e)
      {
         self.onClick( e, self.buttonContainer );
         self.onClickProc( e );
      };
      return elem;
   }
}

class Controls extends VisibleEntity // final
{
   constructor( types, onClickProc = undefined )
   {
      super();
      this.types = types;
      this._onClickProc = onClickProc;
      this.selectedButtons = [];
      const self = this;
      for ( const t in this.types )
      {
         super.addChild( new Button( this.types[t], this, 
            function(e){
                  self.onClick(e);
                  if ( self.onClickProc ) self.onClickProc(e);
               } ) );
      }
   }
   set onClickProc(func)
   {
      this._onClickProc = func;
   }
   get onClickProc()
   {
      return this._onClickProc;
   }
   onClick(e)
   {  
      console.log("Controls onClick");
   }
   create()
   {
      return super.create( "div", {  class:"controlBar "}, this );
   }
}

class ComparisonLine extends VisibleEntity
{
   constructor( sources, effectivity, targets, sortBySourceEffectivity )
   {
      this.sources = [];
      this.effectivity = [];
      this.targets = [];
   }
   create()
   {
      return super.create( "div", {  class:"comparisonLine"}, this );
   }
}

class ComparisonBoxes extends VisibleEntity
{
   constructor()
   {
      this.lines = [];
   }
   addLine(comparisonLine)
   {
      let match = ( comparisonLine.effectivity )
                ? this.lines.find(function(l){ return l.effectivity == comparisonLine.effectivity })[0]
                : undefined;
   }
   create()
   {
      this.children = this.lines;
      return super.create( "div", {  class:"controlBar "}, this );
   }

}
class ComparisonAgainst extends VisibleEntity
{
   constructor( sources, targets )
   {
      this.sourceLines = [];
      this.targetLines = [];

      for( const s in sources )
      {
         const source = sources[s];
         let efficiency = 1;
         for( const t in targets )
         {
            const target = targets[t];




         }
      }

      this.comparisonBoxLeft = new ComparisonBoxes();
      this.comparisonBoxMiddle = new ComparisonBoxes();
      this.comparisonBoxRight = new ComparisonBoxes();


   }
}*/


HTMLElement.prototype.entity = undefined;


const SELECTED_ELEMENT_CLASS = "selectedElement";
const INVISIBLE_ELEMENT_CLASS = "invisibleElement";

class HTMLEntity
{
   constructor( args = {} )
   {
      this._parent = undefined;
      this._children = [];
      this._element = document.createElement( args.type || "div" );
   }

   get parent() { return this._parent; }
   set parent( p ) { this._parent = p; }

   get element() { return this._element; }
   get children() { return this._children; }

   hasClass( className )
   {
      return Boolean( this.element.classList.contains( className ) );
   }
   addClass( className )
   {
      if ( ! this.hasClass( className ) )
      {
         this.element.classList.add( className );
      }
      return this;
   }

   removeClass( className )
   {
      if ( this.hasClass( className ) )
      {
         this.element.classList.remove( className );
      }
      return this;
   }
   toggleClass( className )
   {
      if ( this.hasClass( className ) )
      {
         this.removeClass( className );
      }
      else
      {
         this.addClass( className );
      }
      return this;
   }

   addChild( child, index = -1 )
   {
      if ( child instanceof HTMLEntity )
      {
         this.children.push( child );
         child.parent = this;
         this.element.appendChild( child.element );
      }
      else
      {
         console.error("HTMLEntity.addChild ERROR child not of class HTMLEntity" );
         console.info("parent ", this);
         console.info("child ", child);
      }
      return this;
   }

   addChildren( children )
   {
      children.forEach(e => { this.addChild( e ) });
      return this;
   }
   remove()
   {
      this.children.forEach(c => { c.removeFrom( this.children );
                                   c.remove(); });
      delete this;
   }
   empty( parent = undefined )
   {
      this.children.forEach(c => { c.removeFrom( this.children );
                                   c.remove(); });
      this.element.innerHTML = "";
      return this;
   }

   addOnClickFunc( proc )
   {
      let self = this;
      this.element.addEventListener( "click", function() { proc( self ); });
      return this;
   }

   removeFrom = function( arr )
   {
      let index = arr.indexOf( this );
      if ( index > -1 )
      {
         arr.splice( index, 1 );
      }
      return this;
   }
   pushTo = function( arr )
   {
      arr.push( this );
      return this;
   }
}

class TypeIcon extends HTMLEntity
{
   constructor( type )
   {
      super().addClass("typeIcon").addClass( type.css );
      super.element.innerHTML = type.name;
      this._type = type;
   }
   get type() { return this._type; }
}

class Button extends TypeIcon
{
   constructor( type )
   {
      super( type );
      const self = this;
      self._isSelected = false;

      /*this.addOnClickFunc( function ( e ) {
         
      } );*/
   }
   get selected()
   {
      return this._isSelected;
   }
   set selected( value )
   {
      if ( typeof value === "boolean" )
      {
         if ( value != this._isSelected )
         {
            this._isSelected = value;
            this.toggleClass( SELECTED_ELEMENT_CLASS );
         }
         else
         {
            console.warn("Button.selected: already in state: ", value);
         }
      }
      else
      {
         console.error("Button.selected: trying to set selected to non-bool value ");
         console.log( "value", value );
      }
   }
}

class ControlBar extends HTMLEntity
{
   constructor( onUpdate = undefined )
   {
      super().addClass("controlBar");

      this.selectedButtons = [];
      this.onUpdate = onUpdate;
      const self = this;

      const onButtonClick = function( button )
      {
         if ( self.selectedButtons.includes( button ) )
         {
            self.unselectButton( button );
         }
         else if ( self.selectedButtons.length < 2 )
         {
            self.selectButton( button );
         }
         else {
            self.unselectButton( self.selectedButtons[0] );
            self.selectButton( button );
         }

         self.onUpdate( self );
      }

      TYPES.forEach( type => {
         this.addChild( new Button( type )
                           .addOnClickFunc( function ( button ) { onButtonClick( button ); } )
                      );
      });
   }
   unselectButton( button )
   {
      button.removeFrom( this.selectedButtons );
      button.selected = false;
   }
   selectButton( button )
   {
      if ( this.selectedButtons.length >= 2 )
      {
         this.unselectButton( this.selectedButtons[0] )
      }
      button.pushTo( this.selectedButtons );
      button.selected = true;
   }
}

class Result
{
   constructor( mapPoints, effectivity = 1 )
   {
      this.mapPoints = mapPoints;
      this.effectivity = effectivity;
   }
}


class MapPoint
{
   constructor( types )
   {
      this.types = types;
   }

   get effectiveTo()
   {
      let results = [];

      
   
      return Object.freeze( results );

   }
   get effectiveFrom()
   {
      let results = [];

      for ( const s in sources )
      {
         const sourceType = sources[s];
         const effectivity = sourceType.getEffectivityAgainstTargets( this.types );
         let match = results.filter( function(e) { return e.effectivity == effectivity } )[0];

         if ( !match )
         {
            results.push( new Result( new ResultMapPoint([sourceType]), effectivity ) );
         }
         else
         {
            match.mapPoints.push( new ResultMapPoint([sourceType]) );
         }
      }

      return Object.freeze( results );
   }
}


class ResultColumn extends HTMLEntity
{
   constructor( sourceResult )
   {
      super().addClass("resultLine");
      let results = [];

      for ( const s in sources )
      {
         const sourceType = sources[s];
         const effectivity = sourceType.getEffectivityAgainstTargets( this.types );
         let match = results.filter( function(e) { return e.effectivity == effectivity } )[0];

         if ( !match )
         {
            results.push( new Result( new ResultMapPoint([sourceType]), effectivity ) );
         }
         else
         {
            match.mapPoints.push( new ResultMapPoint([sourceType]) );
         }
      }
   }
}
class ResultBox extends HTMLEntity
{
   constructor( selected )
   {
      super().addClass("resultBox");
      const selectedMapPoint = new MapPoint( selected );
      const resultsFrom = selectedMapPoint.effectiveFrom;
      console.log( resultsFrom );

      this.targetLine = new ResultColumn();
      this.sourceLine = new ResultColumn();
      super.addChildren( [ this.targetLine, this.sourceLine ] );
   }
   static get MODE_FROM_SOURCES() { return 1; }
   static get MODE_TO_TARGETS() { return 2; }



}

class ResultContainer extends HTMLEntity
{
   constructor()
   {
      super().addClass("resultContainer");
   }
}

function init()
{
   let body = document.body;
   let controls = new ControlBar();
   let results = new ResultContainer();
   let resultBox1 = undefined;
   let resultBox2 = undefined;

   controls.onUpdate = function( bar )
   {
      results.empty();
      results.addChildren( new ResultBox() );
   }

   body.appendChild(controls.element);
   body.appendChild(results.element);
}
</script>
<style>
body {
   background-color: #eee;
}
#comparisonContainer {
   width: 100%;
   text-align: center;
   margin-top: 20px;
   background-color: #fff;
}
#innerComparisonContainer {
   margin: 0; padding: 0;
}
.typeIcon {
   display: inline-block;
   cursor: pointer;
   color: white;
   font-size: 25px;
   margin: 4px;
   padding: 8px;
   text-shadow:
   -2px 2px 2px black,
   2px 2px 2px black,
   2px -2px 2px black,
	-2px -2px 2px black;
}
.controlBar {
   display: block;
}
.selectedElement {
   border: 5px dashed white;
}
.comparisonLine{
   display: block;
   text-align: right;
}
.comparisonLineSpacer{
   display: inline-block;
   padding: 4px;
}
.comparisonLineIcon{
   display: inline-block;
   padding: 4px;
}
.comparisonLineEfficiency{
   display: inline-block;
   padding: 4px;
   width: 2em;
   font-weight: bold;
}
.comparisonBox{
   display: inline-block;
   vertical-align: middle;
}
.comparisonSpacerBox{
   display: inline-block;
   padding: 10px;
}
.bug {      background-color: #a8b820; }
.dark {     background-color: #705848; }
.dragon {   background-color: #7038f8; }
.electric { background-color: #f8d030; }
.fairy {    background-color: #68a090; }
.fighting { background-color: #bd2f27; }
.fire {     background-color: #f08030; }
.flying {   background-color: #a890f0; }
.ghost {    background-color: #705898; }
.grass {    background-color: #78c850; }
.ground {   background-color: #e0c068; }
.ice {      background-color: #98d8d8; }
.normal {   background-color: #a8a878; }
.poison {   background-color: #a040a0; }
.psychic {  background-color: #f85888; }
.rock {     background-color: #b8a038; }
.steel {    background-color: #b8b8d0; }
.water {    background-color: #6890f0; }
</style>
</head>
<body onload="init()"></body>
</html>